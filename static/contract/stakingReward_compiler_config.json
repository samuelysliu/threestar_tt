{
	"language": "Solidity",
	"source":{
		"stakingReward.sol":{
			"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract StakingRewards {\n    IERC20 public immutable stakingToken;\n\n    address internal owner;\n    uint public ownerGasFee;\n\n    uint TT = 0;\n\n    // lasttime staking\n    uint public stakingTimestamp;\n    // lasttime withdraw\n    uint public withdrawTimestamp;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n\n    // Total staked\n    uint public totalSupply;\n    // User address => staked amount\n    mapping(address => uint) public balanceOf;\n\n    //all staker address\n    address[] public stakerAddress;\n\n    //stakingEvent\n    event stakingEvent(address staker, uint stakeAmount, uint timestamp);\n    //withdrawEvent\n    event withdrawEvent(address staker, uint withdrawAmount, uint timestamp);\n\n    //received event\n    event Received(address angle, uint amount);\n\n    event withdrawOrder(uint, bool);\n\n    receive() external payable{\n        emit Received(msg.sender, msg.value);\n    }\n\n    constructor(address _stakingToken) payable{\n        owner = msg.sender;\n        stakingToken = IERC20(_stakingToken);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not authorized\");\n        _;\n    }\n\n    modifier updataStakingTimeStamp() {\n        stakingTimestamp = block.timestamp;\n        _;\n    }\n\n    modifier updataWithdrawTimeStamp() {\n        withdrawTimestamp = block.timestamp;\n        _;\n    }\n\n    function stake(uint _amount) external updataStakingTimeStamp(){\n        require(_amount > 0, \"amount = 0\");\n\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n\n        emit stakingEvent(msg.sender, _amount, stakingTimestamp);\n        appendStaker(msg.sender);\n    }\n\n    function withdraw(uint _amount) external payable updataWithdrawTimeStamp(){\n        require(_amount > 0, \"amount <= 0\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient balance\");\n        require(msg.value >= 1000000000000000000);\n\n        ownerGasFee += msg.value;\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n\n        emit withdrawEvent(msg.sender, _amount, withdrawTimestamp);\n    }\n\n    function appendStaker(address _staker) internal returns (bool){\n        for(uint i = 0; i < stakerAddress.length; i++){\n            if(_staker == stakerAddress[i]){\n                return false;\n            }\n        }\n        stakerAddress.push(_staker);\n        return true;\n    }\n\n    function getReward() external{\n        uint reward = rewards[msg.sender];\n       \n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            payable(msg.sender).transfer(reward);\n        }\n    }\n\n    function setReward(uint todayEarn) external onlyOwner {\n        for(uint i = 0; i < stakerAddress.length; i++){\n            rewards[stakerAddress[i]] = balanceOf[stakerAddress[i]] / totalSupply * todayEarn;\n        }\n    }\n\n    function masterWithdraw(uint withdrawAmount) external payable onlyOwner{\n        ownerGasFee -= withdrawAmount;\n        payable(owner).transfer(withdrawAmount);\n        emit withdrawOrder(withdrawAmount, true);\n    }\n}"
		}
	},
	"settings": {
		"optimizer": {
			"enabled": true,
			"runs": 200
		},
		"outputSelection": {
			"*": {
			"": ["ast"],
			"*": ["abi", "metadata", "devdoc", "userdoc", "storageLayout", "evm.legacyAssembly", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.gasEstimates", "evm.assembly"]
			}
		},
		"evmVersion": "byzantium"
	}
}